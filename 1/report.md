# 聊天室设计报告

## 一、聊天协议

1. **用户名输入**：
   - 用户在进入聊天室前需输入用户名，支持任意字符组合（除回车外），包括中文。
   - 输入回车以确认用户名。
   - 聊天室中接收到的消息将显示发送者的用户名，自己发送的消息前将加上“(You)”标识。

2. **消息发送**：
   - 聊天消息可以为任意字符组合（除回车和“quit”外），支持中文。
   - 输入回车发送消息，若输入缓冲区为空，发送操作无效。
   - 输入“quit”发送请求以退出聊天室，执行后客户端将关闭。

3. **服务器状态**：
   - 发送和接收消息需服务器保持开启状态；若服务器关闭，将提示连接失败并退出程序。
   - 聊天消息的顺序按服务器接收时间排列，通常与客户发送顺序一致。

## 二、实现功能

1. **用户自定义用户名**：
   - 用户在进入聊天室时设定用户名，以便在消息中标识发送者。

2. **灵活的消息格式**：
   - 聊天程序允许发送除回车以外的任意字符组合的消息，增强聊天体验。

3. **退出功能**：
   - 客户端可通过输入“quit”请求退出聊天室。
   - 服务器端同样可以输入“quit”来关闭聊天室，断开所有连接。

4. **即时消息刷新**：
   - 客户端在接收到消息后立即刷新聊天界面，将新消息添加到界面末尾，同时输入行刷新到最新消息的下一行。

5. **输入缓冲区缓存**：
   - 当输入行位置变更后，输入缓冲区的内容不会消失，用户可以继续输入。

## 三、实现方法
### 设计思路说明

本聊天室设计采用多线程架构，服务器端通过1+1+n个线程，分别负责输入处理、连接管理和客户消息处理。使用互斥锁确保连接列表的安全访问，避免多线程带来的数据一致性问题。客户端则采用简化的结构，主线程与接收线程分别处理消息的发送与接收，确保用户体验的流畅性。

### 服务器端

#### 线程结构

- **命令线程**：
  - 创建一个专门的线程用于监测服务器端输入，检测到“quit”命令后关闭所有连接。
  
- **连接管理线程**：
  - 主线程负责管理新用户的连接。如果没有客户端发起连接请求，该线程将一直阻塞在`accept`调用上。
  
- **客户线程**：
  - 为每个连接的客户创建独立的线程，负责接收该客户发送的信息并进行广播，同时处理“quit”请求以断开连接。

#### 在连接列表

- **维护连接列表**：
  - 在服务器端维护一个连接列表，记录当前所有连接的客户。每当有新的客户连接或断开时，都需更新此列表。
  
- **互斥锁**：
  - 在访问连接列表时，使用互斥锁以保证线程安全，避免多个线程同时修改连接列表导致数据不一致。
  
- **消息广播**：
  - 当接收到来自某个客户的消息时，广播该消息给连接列表中的所有客户。广播操作需要加锁，以防止在发送消息时连接列表被其他线程修改。

#### 关闭连接

- **停止工作**：
  - 通过在命令线程中设置`running_server`标记为0来通知所有在工作的客户线程停止。每个线程在处理完当前操作后，将退出运行。

- **客户线程的结束**：
  - while循环中添加对`running_server`标记的识别，提前结束未完成工作的信息广播过程。
  - 关闭客户连接前添加互斥锁的调用，避免数据不一致。

- **连接管理线程的结束**：
  - 通过在命令线程中发起新的连接请求，促使连接管理线程跳过`accept`的阻塞状态，确保连接管理线程能够正常接收到`running_server`标记的改变，从而正常结束。

- **关闭连接顺序**
  - 在连接管理线程结束后，发起关闭服务器端的操作（shutdown_server函数）：对所有与客户端连接的套接字执行close操作。
  - 即，客户端与服务器端的连接socket可能在客户线程中自己断开，也可能在关闭服务器端的过程中断开，通过互斥锁，保证了过程的正确性。
  - 在客户线程中自己断开：修改了在连接列表，不会在关闭服务器端中再次关闭；
  - 在关闭服务器端过程中断开：线程函数中client_count已经=0，不会执行任何有效操作。

### 客户端

- **线程结构**：
  - **发送消息线程**：负责将用户输入的消息发送到服务器，实时处理用户输入并将其转发，同时支持缓冲区内容的管理。
  - **接收消息线程**：持续监听服务器发送的消息，将接收到的消息即时显示在聊天界面，并管理输入行的刷新与光标位置。

- **显示处理**：
  - **光标控制**：为了保证输入行始终位于屏幕下方，接收到消息后需将光标位置回退，将新消息打印后再重新打印输入行。
  
  - **输入缓存**：将终端设置为非规范模式，使用`getchar`逐个处理输入字符，从而支持在输入时的光标移动和字符删除功能。
  
  - **用户名逻辑**：在客户端启动时要求用户输入用户名，在发送消息时将用户名作为前缀，接收到消息时加上“(You)”标识。

## 四、未实现功能
本届记录一些可能的进一步的优化方案，因为难度不高不再给予实现，仅提出具体的实现思路。
1. **用户信息广播**：
   - 功能：新用户进入聊天室时，服务器向所有已在聊天室的客户广播新用户的信息。
   - 方法：管理连接线程中，建立连接后调用一次广播函数。

2. **消息时间显示**：
   - 功能：聊天界面在每条消息前显示发送时间，以增强消息的可追溯性。
   - 方法：客户端发送消息前调用一次时间记录函数，附加在发送消息的最开头/末尾（与附加用户名信息在消息前的实现方法一致）。

## 五、总结与体会
通过本次项目，我对Socket编程有了更深入的理解。它不仅仅是一个技术工具，更是实现网络通信的桥梁。在处理Socket时，编写清晰、可维护的代码是非常重要的。同时，良好的线程管理与错误处理机制可以有效提高系统的健壮性。未来在进行网络应用开发时，我会更加注重这些方面的设计与实现，以确保构建出高效、可靠的应用。
